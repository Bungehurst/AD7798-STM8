###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.31.1.20058 [Evaluation] for STM811/Mar/2019  20:52:11 #
# Copyright 2010-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Users\lun55\Desktop\J19B_STM8\Lib\stm8s_tim3.c        #
#    Command line =  C:\Users\lun55\Desktop\J19B_STM8\Lib\stm8s_tim3.c -e     #
#                    -Ol --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_cross_call --debug --code_model small     #
#                    --data_model medium -o C:\Users\lun55\Desktop\J19B_STM8\ #
#                    Debug\Obj\ --dlib_config "D:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\stm8\LIB\dlstm8smf.h" -lcN                    #
#                    C:\Users\lun55\Desktop\J19B_STM8\Debug\List\ -lB         #
#                    C:\Users\lun55\Desktop\J19B_STM8\Debug\List\ --vregs 16  #
#    List file    =  C:\Users\lun55\Desktop\J19B_STM8\Debug\List\stm8s_tim3.l #
#                    st                                                       #
#    Object file  =  C:\Users\lun55\Desktop\J19B_STM8\Debug\Obj\stm8s_tim3.o  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\lun55\Desktop\J19B_STM8\Lib\stm8s_tim3.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8s_tim3.c
      4            * @author  MCD Application Team
      5            * @version V2.2.0
      6            * @date    30-September-2014
      7            * @brief   This file contains all the functions for the TIM3 peripheral.
      8             ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "stm8s_tim3.h"
     30          
     31          /** @addtogroup STM8S_StdPeriph_Driver
     32            * @{
     33            */
     34          /* Private typedef -----------------------------------------------------------*/
     35          /* Private define ------------------------------------------------------------*/
     36          /* Private macro -------------------------------------------------------------*/
     37          /* Private variables ---------------------------------------------------------*/
     38          /* Private function prototypes -----------------------------------------------*/
     39          static void TI1_Config(uint8_t TIM3_ICPolarity, uint8_t TIM3_ICSelection, uint8_t TIM3_ICFilter);
     40          static void TI2_Config(uint8_t TIM3_ICPolarity, uint8_t TIM3_ICSelection, uint8_t TIM3_ICFilter);
     41          /**
     42            * @addtogroup TIM3_Public_Functions
     43            * @{
     44            */
     45          
     46          /**
     47            * @brief  Deinitializes the TIM3 peripheral registers to their default reset values.
     48            * @param  None
     49            * @retval None
     50            */
     51          void TIM3_DeInit(void)
     52          {
     53            TIM3->CR1 = (uint8_t)TIM3_CR1_RESET_VALUE;
     54            TIM3->IER = (uint8_t)TIM3_IER_RESET_VALUE;
     55            TIM3->SR2 = (uint8_t)TIM3_SR2_RESET_VALUE;
     56            
     57            /* Disable channels */
     58            TIM3->CCER1 = (uint8_t)TIM3_CCER1_RESET_VALUE;
     59            
     60            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
     61            TIM3->CCER1 = (uint8_t)TIM3_CCER1_RESET_VALUE;
     62            TIM3->CCMR1 = (uint8_t)TIM3_CCMR1_RESET_VALUE;
     63            TIM3->CCMR2 = (uint8_t)TIM3_CCMR2_RESET_VALUE;
     64            TIM3->CNTRH = (uint8_t)TIM3_CNTRH_RESET_VALUE;
     65            TIM3->CNTRL = (uint8_t)TIM3_CNTRL_RESET_VALUE;
     66            TIM3->PSCR = (uint8_t)TIM3_PSCR_RESET_VALUE;
     67            TIM3->ARRH  = (uint8_t)TIM3_ARRH_RESET_VALUE;
     68            TIM3->ARRL  = (uint8_t)TIM3_ARRL_RESET_VALUE;
     69            TIM3->CCR1H = (uint8_t)TIM3_CCR1H_RESET_VALUE;
     70            TIM3->CCR1L = (uint8_t)TIM3_CCR1L_RESET_VALUE;
     71            TIM3->CCR2H = (uint8_t)TIM3_CCR2H_RESET_VALUE;
     72            TIM3->CCR2L = (uint8_t)TIM3_CCR2L_RESET_VALUE;
     73            TIM3->SR1 = (uint8_t)TIM3_SR1_RESET_VALUE;
     74          }
     75          
     76          /**
     77            * @brief  Initializes the TIM3 Time Base Unit according to the specified parameters.
     78            * @param    TIM3_Prescaler specifies the Prescaler from TIM3_Prescaler_TypeDef.
     79            * @param    TIM3_Period specifies the Period value.
     80            * @retval None
     81            */
     82          void TIM3_TimeBaseInit( TIM3_Prescaler_TypeDef TIM3_Prescaler,
     83                                  uint16_t TIM3_Period)
     84          {
     85            /* Set the Prescaler value */
     86            TIM3->PSCR = (uint8_t)(TIM3_Prescaler);
     87            /* Set the Autoreload value */
     88            TIM3->ARRH = (uint8_t)(TIM3_Period >> 8);
     89            TIM3->ARRL = (uint8_t)(TIM3_Period);
     90          }
     91          
     92          /**
     93            * @brief  Initializes the TIM3 Channel1 according to the specified parameters.
     94            * @param   TIM3_OCMode specifies the Output Compare mode  from @ref TIM3_OCMode_TypeDef.
     95            * @param   TIM3_OutputState specifies the Output State  from @ref TIM3_OutputState_TypeDef.
     96            * @param   TIM3_Pulse specifies the Pulse width  value.
     97            * @param   TIM3_OCPolarity specifies the Output Compare Polarity  from @ref TIM3_OCPolarity_TypeDef.
     98            * @retval None
     99            */
    100          void TIM3_OC1Init(TIM3_OCMode_TypeDef TIM3_OCMode,
    101                            TIM3_OutputState_TypeDef TIM3_OutputState,
    102                            uint16_t TIM3_Pulse,
    103                            TIM3_OCPolarity_TypeDef TIM3_OCPolarity)
    104          {
    105            /* Check the parameters */
    106            assert_param(IS_TIM3_OC_MODE_OK(TIM3_OCMode));
    107            assert_param(IS_TIM3_OUTPUT_STATE_OK(TIM3_OutputState));
    108            assert_param(IS_TIM3_OC_POLARITY_OK(TIM3_OCPolarity));
    109            
    110            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , the Output Polarity */
    111            TIM3->CCER1 &= (uint8_t)(~( TIM3_CCER1_CC1E | TIM3_CCER1_CC1P));
    112            /* Set the Output State &  Set the Output Polarity  */
    113            TIM3->CCER1 |= (uint8_t)((uint8_t)(TIM3_OutputState  & TIM3_CCER1_CC1E   ) | (uint8_t)(TIM3_OCPolarity   & TIM3_CCER1_CC1P   ));
    114            
    115            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    116            TIM3->CCMR1 = (uint8_t)((uint8_t)(TIM3->CCMR1 & (uint8_t)(~TIM3_CCMR_OCM)) | (uint8_t)TIM3_OCMode);
    117            
    118            /* Set the Pulse value */
    119            TIM3->CCR1H = (uint8_t)(TIM3_Pulse >> 8);
    120            TIM3->CCR1L = (uint8_t)(TIM3_Pulse);
    121          }
    122          
    123          /**
    124            * @brief  Initializes the TIM3 Channel2 according to the specified parameters.
    125            * @param   TIM3_OCMode specifies the Output Compare mode  from @ref TIM3_OCMode_TypeDef.
    126            * @param   TIM3_OutputState specifies the Output State  from @ref TIM3_OutputState_TypeDef.
    127            * @param   TIM3_Pulse specifies the Pulse width  value.
    128            * @param   TIM3_OCPolarity specifies the Output Compare Polarity  from @ref TIM3_OCPolarity_TypeDef.
    129            * @retval None
    130            */
    131          void TIM3_OC2Init(TIM3_OCMode_TypeDef TIM3_OCMode,
    132                            TIM3_OutputState_TypeDef TIM3_OutputState,
    133                            uint16_t TIM3_Pulse,
    134                            TIM3_OCPolarity_TypeDef TIM3_OCPolarity)
    135          {
    136            /* Check the parameters */
    137            assert_param(IS_TIM3_OC_MODE_OK(TIM3_OCMode));
    138            assert_param(IS_TIM3_OUTPUT_STATE_OK(TIM3_OutputState));
    139            assert_param(IS_TIM3_OC_POLARITY_OK(TIM3_OCPolarity));
    140            
    141            
    142            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State, the Output Polarity */
    143            TIM3->CCER1 &= (uint8_t)(~( TIM3_CCER1_CC2E |  TIM3_CCER1_CC2P ));
    144            /* Set the Output State & Set the Output Polarity */
    145            TIM3->CCER1 |= (uint8_t)((uint8_t)(TIM3_OutputState  & TIM3_CCER1_CC2E   ) | (uint8_t)(TIM3_OCPolarity   & TIM3_CCER1_CC2P ));
    146            
    147            
    148            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    149            TIM3->CCMR2 = (uint8_t)((uint8_t)(TIM3->CCMR2 & (uint8_t)(~TIM3_CCMR_OCM)) | (uint8_t)TIM3_OCMode);
    150            
    151            
    152            /* Set the Pulse value */
    153            TIM3->CCR2H = (uint8_t)(TIM3_Pulse >> 8);
    154            TIM3->CCR2L = (uint8_t)(TIM3_Pulse);
    155          }
    156          
    157          /**
    158            * @brief  Initializes the TIM3 peripheral according to the specified parameters.
    159            * @param    TIM3_Channel specifies the Input Capture Channel from @ref TIM3_Channel_TypeDef.
    160            * @param   TIM3_ICPolarity specifies the Input Capture Polarity from @ref TIM3_ICPolarity_TypeDef.
    161            * @param   TIM3_ICSelection specifies the Input Capture Selection from @ref TIM3_ICSelection_TypeDef.
    162            * @param   TIM3_ICPrescaler specifies the Input Capture Prescaler from @ref TIM3_ICPSC_TypeDef.
    163            * @param   TIM3_ICFilter specifies the Input Capture Filter value (value can be an integer from 0x00 to 0x0F).
    164            * @retval None
    165            */
    166          void TIM3_ICInit(TIM3_Channel_TypeDef TIM3_Channel,
    167                           TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
    168                           TIM3_ICSelection_TypeDef TIM3_ICSelection,
    169                           TIM3_ICPSC_TypeDef TIM3_ICPrescaler,
    170                           uint8_t TIM3_ICFilter)
    171          {
    172            /* Check the parameters */
    173            assert_param(IS_TIM3_CHANNEL_OK(TIM3_Channel));
    174            assert_param(IS_TIM3_IC_POLARITY_OK(TIM3_ICPolarity));
    175            assert_param(IS_TIM3_IC_SELECTION_OK(TIM3_ICSelection));
    176            assert_param(IS_TIM3_IC_PRESCALER_OK(TIM3_ICPrescaler));
    177            assert_param(IS_TIM3_IC_FILTER_OK(TIM3_ICFilter));
    178            
    179            if (TIM3_Channel != TIM3_CHANNEL_2)
    180            {
    181              /* TI1 Configuration */
    182              TI1_Config((uint8_t)TIM3_ICPolarity,
    183                         (uint8_t)TIM3_ICSelection,
    184                         (uint8_t)TIM3_ICFilter);
    185              
    186              /* Set the Input Capture Prescaler value */
    187              TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
    188            }
    189            else
    190            {
    191              /* TI2 Configuration */
    192              TI2_Config((uint8_t)TIM3_ICPolarity,
    193                         (uint8_t)TIM3_ICSelection,
    194                         (uint8_t)TIM3_ICFilter);
    195              
    196              /* Set the Input Capture Prescaler value */
    197              TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
    198            }
    199          }
    200          
    201          /**
    202            * @brief  Configures the TIM3 peripheral in PWM Input Mode according to the specified parameters.
    203            * @param    TIM3_Channel specifies the Input Capture Channel from @ref TIM3_Channel_TypeDef.
    204            * @param   TIM3_ICPolarity specifies the Input Capture Polarity from @ref TIM3_ICPolarity_TypeDef.
    205            * @param   TIM3_ICSelection specifies the Input Capture Selection from @ref TIM3_ICSelection_TypeDef.
    206            * @param   TIM3_ICPrescaler specifies the Input Capture Prescaler from @ref TIM3_ICPSC_TypeDef.
    207            * @param   TIM3_ICFilter specifies the Input Capture Filter value (value can be an integer from 0x00 to 0x0F).
    208            * @retval None
    209            */
    210          void TIM3_PWMIConfig(TIM3_Channel_TypeDef TIM3_Channel,
    211                               TIM3_ICPolarity_TypeDef TIM3_ICPolarity,
    212                               TIM3_ICSelection_TypeDef TIM3_ICSelection,
    213                               TIM3_ICPSC_TypeDef TIM3_ICPrescaler,
    214                               uint8_t TIM3_ICFilter)
    215          {
    216            uint8_t icpolarity = (uint8_t)TIM3_ICPOLARITY_RISING;
    217            uint8_t icselection = (uint8_t)TIM3_ICSELECTION_DIRECTTI;
    218            
    219            /* Check the parameters */
    220            assert_param(IS_TIM3_PWMI_CHANNEL_OK(TIM3_Channel));
    221            assert_param(IS_TIM3_IC_POLARITY_OK(TIM3_ICPolarity));
    222            assert_param(IS_TIM3_IC_SELECTION_OK(TIM3_ICSelection));
    223            assert_param(IS_TIM3_IC_PRESCALER_OK(TIM3_ICPrescaler));
    224            
    225            /* Select the Opposite Input Polarity */
    226            if (TIM3_ICPolarity != TIM3_ICPOLARITY_FALLING)
    227            {
    228              icpolarity = (uint8_t)TIM3_ICPOLARITY_FALLING;
    229            }
    230            else
    231            {
    232              icpolarity = (uint8_t)TIM3_ICPOLARITY_RISING;
    233            }
    234            
    235            /* Select the Opposite Input */
    236            if (TIM3_ICSelection == TIM3_ICSELECTION_DIRECTTI)
    237            {
    238              icselection = (uint8_t)TIM3_ICSELECTION_INDIRECTTI;
    239            }
    240            else
    241            {
    242              icselection = (uint8_t)TIM3_ICSELECTION_DIRECTTI;
    243            }
    244            
    245            if (TIM3_Channel != TIM3_CHANNEL_2)
    246            {
    247              /* TI1 Configuration */
    248              TI1_Config((uint8_t)TIM3_ICPolarity, (uint8_t)TIM3_ICSelection,
    249                         (uint8_t)TIM3_ICFilter);
    250              
    251              /* Set the Input Capture Prescaler value */
    252              TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
    253              
    254              /* TI2 Configuration */
    255              TI2_Config(icpolarity, icselection, TIM3_ICFilter);
    256              
    257              /* Set the Input Capture Prescaler value */
    258              TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
    259            }
    260            else
    261            {
    262              /* TI2 Configuration */
    263              TI2_Config((uint8_t)TIM3_ICPolarity, (uint8_t)TIM3_ICSelection,
    264                         (uint8_t)TIM3_ICFilter);
    265              
    266              /* Set the Input Capture Prescaler value */
    267              TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
    268              
    269              /* TI1 Configuration */
    270              TI1_Config(icpolarity, icselection, TIM3_ICFilter);
    271              
    272              /* Set the Input Capture Prescaler value */
    273              TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
    274            }
    275          }
    276          
    277          /**
    278            * @brief  Enables or disables the TIM3 peripheral.
    279            * @param   NewState new state of the TIM3 peripheral. This parameter can
    280            * be ENABLE or DISABLE.
    281            * @retval None
    282            */
    283          void TIM3_Cmd(FunctionalState NewState)
    284          {
    285            /* Check the parameters */
    286            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    287            
    288            /* set or Reset the CEN Bit */
    289            if (NewState != DISABLE)
    290            {
    291              TIM3->CR1 |= (uint8_t)TIM3_CR1_CEN;
    292            }
    293            else
    294            {
    295              TIM3->CR1 &= (uint8_t)(~TIM3_CR1_CEN);
    296            }
    297          }
    298          
    299          /**
    300            * @brief  Enables or disables the specified TIM3 interrupts.
    301            * @param   NewState new state of the TIM3 peripheral.
    302            * This parameter can be: ENABLE or DISABLE.
    303            * @param   TIM3_IT specifies the TIM3 interrupts sources to be enabled or disabled.
    304            * This parameter can be any combination of the following values:
    305            *                       - TIM3_IT_UPDATE: TIM3 update Interrupt source
    306            *                       - TIM3_IT_CC1: TIM3 Capture Compare 1 Interrupt source
    307            *                       - TIM3_IT_CC2: TIM3 Capture Compare 2 Interrupt source
    308            *                       - TIM3_IT_CC3: TIM3 Capture Compare 3 Interrupt source
    309            * @param   NewState new state of the TIM3 peripheral.  * @retval None
    310            */
    311          void TIM3_ITConfig(TIM3_IT_TypeDef TIM3_IT, FunctionalState NewState)
    312          {
    313            /* Check the parameters */
    314            assert_param(IS_TIM3_IT_OK(TIM3_IT));
    315            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    316            
    317            if (NewState != DISABLE)
    318            {
    319              /* Enable the Interrupt sources */
    320              TIM3->IER |= (uint8_t)TIM3_IT;
    321            }
    322            else
    323            {
    324              /* Disable the Interrupt sources */
    325              TIM3->IER &= (uint8_t)(~TIM3_IT);
    326            }
    327          }
    328          
    329          /**
    330            * @brief  Enables or Disables the TIM3 Update event.
    331            * @param   NewState new state of the TIM3 peripheral Preload register. This parameter can
    332            * be ENABLE or DISABLE.
    333            * @retval None
    334            */
    335          void TIM3_UpdateDisableConfig(FunctionalState NewState)
    336          {
    337            /* Check the parameters */
    338            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    339            
    340            /* Set or Reset the UDIS Bit */
    341            if (NewState != DISABLE)
    342            {
    343              TIM3->CR1 |= TIM3_CR1_UDIS;
    344            }
    345            else
    346            {
    347              TIM3->CR1 &= (uint8_t)(~TIM3_CR1_UDIS);
    348            }
    349          }
    350          
    351          /**
    352            * @brief  Selects the TIM3 Update Request Interrupt source.
    353            * @param   TIM3_UpdateSource specifies the Update source.
    354            * This parameter can be one of the following values
    355            *                       - TIM3_UPDATESOURCE_REGULAR
    356            *                       - TIM3_UPDATESOURCE_GLOBAL
    357            * @retval None
    358            */
    359          void TIM3_UpdateRequestConfig(TIM3_UpdateSource_TypeDef TIM3_UpdateSource)
    360          {
    361            /* Check the parameters */
    362            assert_param(IS_TIM3_UPDATE_SOURCE_OK(TIM3_UpdateSource));
    363            
    364            /* Set or Reset the URS Bit */
    365            if (TIM3_UpdateSource != TIM3_UPDATESOURCE_GLOBAL)
    366            {
    367              TIM3->CR1 |= TIM3_CR1_URS;
    368            }
    369            else
    370            {
    371              TIM3->CR1 &= (uint8_t)(~TIM3_CR1_URS);
    372            }
    373          }
    374          
    375          /**
    376            * @brief  Selects the TIM3’s One Pulse Mode.
    377            * @param   TIM3_OPMode specifies the OPM Mode to be used.
    378            * This parameter can be one of the following values
    379            *                    - TIM3_OPMODE_SINGLE
    380            *                    - TIM3_OPMODE_REPETITIVE
    381            * @retval None
    382            */
    383          void TIM3_SelectOnePulseMode(TIM3_OPMode_TypeDef TIM3_OPMode)
    384          {
    385            /* Check the parameters */
    386            assert_param(IS_TIM3_OPM_MODE_OK(TIM3_OPMode));
    387            
    388            /* Set or Reset the OPM Bit */
    389            if (TIM3_OPMode != TIM3_OPMODE_REPETITIVE)
    390            {
    391              TIM3->CR1 |= TIM3_CR1_OPM;
    392            }
    393            else
    394            {
    395              TIM3->CR1 &= (uint8_t)(~TIM3_CR1_OPM);
    396            }
    397          }
    398          
    399          /**
    400            * @brief  Configures the TIM3 Prescaler.
    401            * @param   Prescaler specifies the Prescaler Register value
    402            * This parameter can be one of the following values
    403            *                       -  TIM3_PRESCALER_1
    404            *                       -  TIM3_PRESCALER_2
    405            *                       -  TIM3_PRESCALER_4
    406            *                       -  TIM3_PRESCALER_8
    407            *                       -  TIM3_PRESCALER_16
    408            *                       -  TIM3_PRESCALER_32
    409            *                       -  TIM3_PRESCALER_64
    410            *                       -  TIM3_PRESCALER_128
    411            *                       -  TIM3_PRESCALER_256
    412            *                       -  TIM3_PRESCALER_512
    413            *                       -  TIM3_PRESCALER_1024
    414            *                       -  TIM3_PRESCALER_2048
    415            *                       -  TIM3_PRESCALER_4096
    416            *                       -  TIM3_PRESCALER_8192
    417            *                       -  TIM3_PRESCALER_16384
    418            *                       -  TIM3_PRESCALER_32768
    419            * @param   TIM3_PSCReloadMode specifies the TIM3 Prescaler Reload mode.
    420            * This parameter can be one of the following values
    421            *                       - TIM3_PSCRELOADMODE_IMMEDIATE: The Prescaler is loaded
    422            *                         immediately.
    423            *                       - TIM3_PSCRELOADMODE_UPDATE: The Prescaler is loaded at
    424            *                         the update event.
    425            * @retval None
    426            */
    427          void TIM3_PrescalerConfig(TIM3_Prescaler_TypeDef Prescaler,
    428                                    TIM3_PSCReloadMode_TypeDef TIM3_PSCReloadMode)
    429          {
    430            /* Check the parameters */
    431            assert_param(IS_TIM3_PRESCALER_RELOAD_OK(TIM3_PSCReloadMode));
    432            assert_param(IS_TIM3_PRESCALER_OK(Prescaler));
    433            
    434            /* Set the Prescaler value */
    435            TIM3->PSCR = (uint8_t)Prescaler;
    436            
    437            /* Set or reset the UG Bit */
    438            TIM3->EGR = (uint8_t)TIM3_PSCReloadMode;
    439          }
    440          
    441          /**
    442            * @brief  Forces the TIM3 Channel1 output waveform to active or inactive level.
    443            * @param   TIM3_ForcedAction specifies the forced Action to be set to the output waveform.
    444            * This parameter can be one of the following values:
    445            *                       - TIM3_FORCEDACTION_ACTIVE: Force active level on OC1REF
    446            *                       - TIM3_FORCEDACTION_INACTIVE: Force inactive level on
    447            *                         OC1REF.
    448            * @retval None
    449            */
    450          void TIM3_ForcedOC1Config(TIM3_ForcedAction_TypeDef TIM3_ForcedAction)
    451          {
    452            /* Check the parameters */
    453            assert_param(IS_TIM3_FORCED_ACTION_OK(TIM3_ForcedAction));
    454            
    455            /* Reset the OCM Bits & Configure the Forced output Mode */
    456            TIM3->CCMR1 =  (uint8_t)((uint8_t)(TIM3->CCMR1 & (uint8_t)(~TIM3_CCMR_OCM))  | (uint8_t)TIM3_ForcedAction);
    457          }
    458          
    459          /**
    460            * @brief  Forces the TIM3 Channel2 output waveform to active or inactive level.
    461            * @param   TIM3_ForcedAction specifies the forced Action to be set to the output waveform.
    462            * This parameter can be one of the following values:
    463            *                       - TIM3_FORCEDACTION_ACTIVE: Force active level on OC2REF
    464            *                       - TIM3_FORCEDACTION_INACTIVE: Force inactive level on
    465            *                         OC2REF.
    466            * @retval None
    467            */
    468          void TIM3_ForcedOC2Config(TIM3_ForcedAction_TypeDef TIM3_ForcedAction)
    469          {
    470            /* Check the parameters */
    471            assert_param(IS_TIM3_FORCED_ACTION_OK(TIM3_ForcedAction));
    472            
    473            /* Reset the OCM Bits & Configure the Forced output Mode */
    474            TIM3->CCMR2 =  (uint8_t)((uint8_t)(TIM3->CCMR2 & (uint8_t)(~TIM3_CCMR_OCM)) | (uint8_t)TIM3_ForcedAction);
    475          }
    476          
    477          /**
    478            * @brief  Enables or disables TIM3 peripheral Preload register on ARR.
    479            * @param   NewState new state of the TIM3 peripheral Preload register.
    480            * This parameter can be ENABLE or DISABLE.
    481            * @retval None
    482            */
    483          void TIM3_ARRPreloadConfig(FunctionalState NewState)
    484          {
    485            /* Check the parameters */
    486            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    487            
    488            /* Set or Reset the ARPE Bit */
    489            if (NewState != DISABLE)
    490            {
    491              TIM3->CR1 |= TIM3_CR1_ARPE;
    492            }
    493            else
    494            {
    495              TIM3->CR1 &= (uint8_t)(~TIM3_CR1_ARPE);
    496            }
    497          }
    498          
    499          /**
    500            * @brief  Enables or disables the TIM3 peripheral Preload Register on CCR1.
    501            * @param   NewState new state of the Capture Compare Preload register.
    502            * This parameter can be ENABLE or DISABLE.
    503            * @retval None
    504            */
    505          void TIM3_OC1PreloadConfig(FunctionalState NewState)
    506          {
    507            /* Check the parameters */
    508            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    509            
    510            /* Set or Reset the OC1PE Bit */
    511            if (NewState != DISABLE)
    512            {
    513              TIM3->CCMR1 |= TIM3_CCMR_OCxPE;
    514            }
    515            else
    516            {
    517              TIM3->CCMR1 &= (uint8_t)(~TIM3_CCMR_OCxPE);
    518            }
    519          }
    520          
    521          /**
    522            * @brief  Enables or disables the TIM3 peripheral Preload Register on CCR2.
    523            * @param   NewState new state of the Capture Compare Preload register.
    524            * This parameter can be ENABLE or DISABLE.
    525            * @retval None
    526            */
    527          void TIM3_OC2PreloadConfig(FunctionalState NewState)
    528          {
    529            /* Check the parameters */
    530            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    531            
    532            /* Set or Reset the OC2PE Bit */
    533            if (NewState != DISABLE)
    534            {
    535              TIM3->CCMR2 |= TIM3_CCMR_OCxPE;
    536            }
    537            else
    538            {
    539              TIM3->CCMR2 &= (uint8_t)(~TIM3_CCMR_OCxPE);
    540            }
    541          }
    542          
    543          /**
    544            * @brief  Configures the TIM3 event to be generated by software.
    545            * @param   TIM3_EventSource specifies the event source.
    546            * This parameter can be one of the following values:
    547            *                       - TIM3_EVENTSOURCE_UPDATE: TIM3 update Event source
    548            *                       - TIM3_EVENTSOURCE_CC1: TIM3 Capture Compare 1 Event source
    549            *                       - TIM3_EVENTSOURCE_CC2: TIM3 Capture Compare 2 Event source
    550            * @retval None
    551            */
    552          void TIM3_GenerateEvent(TIM3_EventSource_TypeDef TIM3_EventSource)
    553          {
    554            /* Check the parameters */
    555            assert_param(IS_TIM3_EVENT_SOURCE_OK(TIM3_EventSource));
    556            
    557            /* Set the event sources */
    558            TIM3->EGR = (uint8_t)TIM3_EventSource;
    559          }
    560          
    561          /**
    562            * @brief  Configures the TIM3 Channel 1 polarity.
    563            * @param   TIM3_OCPolarity specifies the OC1 Polarity.
    564            * This parameter can be one of the following values:
    565            *                       - TIM3_OCPOLARITY_LOW: Output Compare active low
    566            *                       - TIM3_OCPOLARITY_HIGH: Output Compare active high
    567            * @retval None
    568            */
    569          void TIM3_OC1PolarityConfig(TIM3_OCPolarity_TypeDef TIM3_OCPolarity)
    570          {
    571            /* Check the parameters */
    572            assert_param(IS_TIM3_OC_POLARITY_OK(TIM3_OCPolarity));
    573            
    574            /* Set or Reset the CC1P Bit */
    575            if (TIM3_OCPolarity != TIM3_OCPOLARITY_HIGH)
    576            {
    577              TIM3->CCER1 |= TIM3_CCER1_CC1P;
    578            }
    579            else
    580            {
    581              TIM3->CCER1 &= (uint8_t)(~TIM3_CCER1_CC1P);
    582            }
    583          }
    584          
    585          /**
    586            * @brief  Configures the TIM3 Channel 2 polarity.
    587            * @param   TIM3_OCPolarity specifies the OC2 Polarity.
    588            * This parameter can be one of the following values:
    589            *                       - TIM3_OCPOLARITY_LOW: Output Compare active low
    590            *                       - TIM3_OCPOLARITY_HIGH: Output Compare active high
    591            * @retval None
    592            */
    593          void TIM3_OC2PolarityConfig(TIM3_OCPolarity_TypeDef TIM3_OCPolarity)
    594          {
    595            /* Check the parameters */
    596            assert_param(IS_TIM3_OC_POLARITY_OK(TIM3_OCPolarity));
    597            
    598            /* Set or Reset the CC2P Bit */
    599            if (TIM3_OCPolarity != TIM3_OCPOLARITY_HIGH)
    600            {
    601              TIM3->CCER1 |= TIM3_CCER1_CC2P;
    602            }
    603            else
    604            {
    605              TIM3->CCER1 &= (uint8_t)(~TIM3_CCER1_CC2P);
    606            }
    607          }
    608          
    609          /**
    610            * @brief  Enables or disables the TIM3 Capture Compare Channel x.
    611            * @param   TIM3_Channel specifies the TIM3 Channel.
    612            * This parameter can be one of the following values:
    613            *                       - TIM3_CHANNEL_1: TIM3 Channel1
    614            *                       - TIM3_CHANNEL_2: TIM3 Channel2
    615            * @param   NewState specifies the TIM3 Channel CCxE bit new state.
    616            * This parameter can be: ENABLE or DISABLE.
    617            * @retval None
    618            */
    619          void TIM3_CCxCmd(TIM3_Channel_TypeDef TIM3_Channel, FunctionalState NewState)
    620          {
    621            /* Check the parameters */
    622            assert_param(IS_TIM3_CHANNEL_OK(TIM3_Channel));
    623            assert_param(IS_FUNCTIONALSTATE_OK(NewState));
    624            
    625            if (TIM3_Channel == TIM3_CHANNEL_1)
    626            {
    627              /* Set or Reset the CC1E Bit */
    628              if (NewState != DISABLE)
    629              {
    630                TIM3->CCER1 |= TIM3_CCER1_CC1E;
    631              }
    632              else
    633              {
    634                TIM3->CCER1 &= (uint8_t)(~TIM3_CCER1_CC1E);
    635              }
    636              
    637            }
    638            else
    639            {
    640              /* Set or Reset the CC2E Bit */
    641              if (NewState != DISABLE)
    642              {
    643                TIM3->CCER1 |= TIM3_CCER1_CC2E;
    644              }
    645              else
    646              {
    647                TIM3->CCER1 &= (uint8_t)(~TIM3_CCER1_CC2E);
    648              }
    649            }
    650          }
    651          
    652          /**
    653            * @brief  Selects the TIM3 Output Compare Mode. This function disables the
    654            * selected channel before changing the Output Compare Mode. User has to
    655            * enable this channel using TIM3_CCxCmd and TIM3_CCxNCmd functions.
    656            * @param   TIM3_Channel specifies the TIM3 Channel.
    657            * This parameter can be one of the following values:
    658            *                       - TIM3_CHANNEL_1: TIM3 Channel1
    659            *                       - TIM3_CHANNEL_2: TIM3 Channel2
    660            * @param   TIM3_OCMode specifies the TIM3 Output Compare Mode.
    661            * This parameter can be one of the following values:
    662            *                       - TIM3_OCMODE_TIMING
    663            *                       - TIM3_OCMODE_ACTIVE
    664            *                       - TIM3_OCMODE_TOGGLE
    665            *                       - TIM3_OCMODE_PWM1
    666            *                       - TIM3_OCMODE_PWM2
    667            *                       - TIM3_FORCEDACTION_ACTIVE
    668            *                       - TIM3_FORCEDACTION_INACTIVE
    669            * @retval None
    670            */
    671          void TIM3_SelectOCxM(TIM3_Channel_TypeDef TIM3_Channel, TIM3_OCMode_TypeDef TIM3_OCMode)
    672          {
    673            /* Check the parameters */
    674            assert_param(IS_TIM3_CHANNEL_OK(TIM3_Channel));
    675            assert_param(IS_TIM3_OCM_OK(TIM3_OCMode));
    676            
    677            if (TIM3_Channel == TIM3_CHANNEL_1)
    678            {
    679              /* Disable the Channel 1: Reset the CCE Bit */
    680              TIM3->CCER1 &= (uint8_t)(~TIM3_CCER1_CC1E);
    681              
    682              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    683              TIM3->CCMR1 = (uint8_t)((uint8_t)(TIM3->CCMR1 & (uint8_t)(~TIM3_CCMR_OCM)) | (uint8_t)TIM3_OCMode);
    684            }
    685            else
    686            {
    687              /* Disable the Channel 2: Reset the CCE Bit */
    688              TIM3->CCER1 &= (uint8_t)(~TIM3_CCER1_CC2E);
    689              
    690              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    691              TIM3->CCMR2 = (uint8_t)((uint8_t)(TIM3->CCMR2 & (uint8_t)(~TIM3_CCMR_OCM)) | (uint8_t)TIM3_OCMode);
    692            }
    693          }
    694          
    695          /**
    696            * @brief  Sets the TIM3 Counter Register value.
    697            * @param   Counter specifies the Counter register new value.
    698            * This parameter is between 0x0000 and 0xFFFF.
    699            * @retval None
    700            */
    701          void TIM3_SetCounter(uint16_t Counter)
    702          {
    703            /* Set the Counter Register value */
    704            TIM3->CNTRH = (uint8_t)(Counter >> 8);
    705            TIM3->CNTRL = (uint8_t)(Counter);
    706          }
    707          
    708          /**
    709            * @brief  Sets the TIM3 Autoreload Register value.
    710            * @param   Autoreload specifies the Autoreload register new value.
    711            * This parameter is between 0x0000 and 0xFFFF.
    712            * @retval None
    713            */
    714          void TIM3_SetAutoreload(uint16_t Autoreload)
    715          {
    716            /* Set the Autoreload Register value */
    717            TIM3->ARRH = (uint8_t)(Autoreload >> 8);
    718            TIM3->ARRL = (uint8_t)(Autoreload);
    719          }
    720          
    721          /**
    722            * @brief  Sets the TIM3 Capture Compare1 Register value.
    723            * @param   Compare1 specifies the Capture Compare1 register new value.
    724            * This parameter is between 0x0000 and 0xFFFF.
    725            * @retval None
    726            */
    727          void TIM3_SetCompare1(uint16_t Compare1)
    728          {
    729            /* Set the Capture Compare1 Register value */
    730            TIM3->CCR1H = (uint8_t)(Compare1 >> 8);
    731            TIM3->CCR1L = (uint8_t)(Compare1);
    732          }
    733          
    734          /**
    735            * @brief  Sets the TIM3 Capture Compare2 Register value.
    736            * @param   Compare2 specifies the Capture Compare2 register new value.
    737            * This parameter is between 0x0000 and 0xFFFF.
    738            * @retval None
    739            */
    740          void TIM3_SetCompare2(uint16_t Compare2)
    741          {
    742            /* Set the Capture Compare2 Register value */
    743            TIM3->CCR2H = (uint8_t)(Compare2 >> 8);
    744            TIM3->CCR2L = (uint8_t)(Compare2);
    745          }
    746          
    747          /**
    748            * @brief  Sets the TIM3 Input Capture 1 prescaler.
    749            * @param   TIM3_IC1Prescaler specifies the Input Capture prescaler new value
    750            * This parameter can be one of the following values:
    751            *                       - TIM3_ICPSC_DIV1: no prescaler
    752            *                       - TIM3_ICPSC_DIV2: capture is done once every 2 events
    753            *                       - TIM3_ICPSC_DIV4: capture is done once every 4 events
    754            *                       - TIM3_ICPSC_DIV8: capture is done once every 8 events
    755            * @retval None
    756            */
    757          void TIM3_SetIC1Prescaler(TIM3_ICPSC_TypeDef TIM3_IC1Prescaler)
    758          {
    759            /* Check the parameters */
    760            assert_param(IS_TIM3_IC_PRESCALER_OK(TIM3_IC1Prescaler));
    761            
    762            /* Reset the IC1PSC Bits & Set the IC1PSC value */
    763            TIM3->CCMR1 = (uint8_t)((uint8_t)(TIM3->CCMR1 & (uint8_t)(~TIM3_CCMR_ICxPSC)) | (uint8_t)TIM3_IC1Prescaler);
    764          }
    765          
    766          /**
    767            * @brief  Sets the TIM3 Input Capture 2 prescaler.
    768            * @param   TIM3_IC2Prescaler specifies the Input Capture prescaler new value
    769            * This parameter can be one of the following values:
    770            *                       - TIM3_ICPSC_DIV1: no prescaler
    771            *                       - TIM3_ICPSC_DIV2: capture is done once every 2 events
    772            *                       - TIM3_ICPSC_DIV4: capture is done once every 4 events
    773            *                       - TIM3_ICPSC_DIV8: capture is done once every 8 events
    774            * @retval None
    775            */
    776          void TIM3_SetIC2Prescaler(TIM3_ICPSC_TypeDef TIM3_IC2Prescaler)
    777          {
    778            /* Check the parameters */
    779            assert_param(IS_TIM3_IC_PRESCALER_OK(TIM3_IC2Prescaler));
    780            
    781            /* Reset the IC1PSC Bits & Set the IC1PSC value */
    782            TIM3->CCMR2 = (uint8_t)((uint8_t)(TIM3->CCMR2 & (uint8_t)(~TIM3_CCMR_ICxPSC)) | (uint8_t)TIM3_IC2Prescaler);
    783          }
    784          
    785          /**
    786            * @brief  Gets the TIM3 Input Capture 1 value.
    787            * @param  None
    788            * @retval Capture Compare 1 Register value.
    789            */
    790          uint16_t TIM3_GetCapture1(void)
    791          {
    792            /* Get the Capture 1 Register value */
    793            uint16_t tmpccr1 = 0;
    794            uint8_t tmpccr1l=0, tmpccr1h=0;
    795            
    796            tmpccr1h = TIM3->CCR1H;
    797            tmpccr1l = TIM3->CCR1L;
    798            
    799            tmpccr1 = (uint16_t)(tmpccr1l);
    800            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
    801            /* Get the Capture 1 Register value */
    802            return (uint16_t)tmpccr1;
    803          }
    804          
    805          /**
    806            * @brief  Gets the TIM3 Input Capture 2 value.
    807            * @param  None
    808            * @retval Capture Compare 2 Register value.
    809            */
    810          uint16_t TIM3_GetCapture2(void)
    811          {
    812            /* Get the Capture 2 Register value */
    813            uint16_t tmpccr2 = 0;
    814            uint8_t tmpccr2l=0, tmpccr2h=0;
    815            
    816            tmpccr2h = TIM3->CCR2H;
    817            tmpccr2l = TIM3->CCR2L;
    818            
    819            tmpccr2 = (uint16_t)(tmpccr2l);
    820            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
    821            /* Get the Capture 2 Register value */
    822            return (uint16_t)tmpccr2;
    823          }
    824          
    825          /**
    826            * @brief  Gets the TIM3 Counter value.
    827            * @param  None
    828            * @retval Counter Register value.
    829            */
    830          uint16_t TIM3_GetCounter(void)
    831          {
    832            uint16_t tmpcntr = 0;
    833            
    834            tmpcntr = ((uint16_t)TIM3->CNTRH << 8);
    835            /* Get the Counter Register value */
    836            return (uint16_t)( tmpcntr| (uint16_t)(TIM3->CNTRL));
    837          }
    838          
    839          /**
    840            * @brief  Gets the TIM3 Prescaler value.
    841            * @param  None
    842            * @retval Prescaler Register configuration value @ref TIM3_Prescaler_TypeDef.
    843            */
    844          TIM3_Prescaler_TypeDef TIM3_GetPrescaler(void)
    845          {
    846            /* Get the Prescaler Register value */
    847            return (TIM3_Prescaler_TypeDef)(TIM3->PSCR);
    848          }
    849          
    850          /**
    851            * @brief  Checks whether the specified TIM3 flag is set or not.
    852            * @param   TIM3_FLAG specifies the flag to check.
    853            * This parameter can be one of the following values:
    854            *                       - TIM3_FLAG_UPDATE: TIM3 update Flag
    855            *                       - TIM3_FLAG_CC1: TIM3 Capture Compare 1 Flag
    856            *                       - TIM3_FLAG_CC2: TIM3 Capture Compare 2 Flag
    857            *                       - TIM3_FLAG_CC1OF: TIM3 Capture Compare 1 over capture Flag
    858            *                       - TIM3_FLAG_CC2OF: TIM3 Capture Compare 2 over capture Flag
    859            * @retval FlagStatus The new state of TIM3_FLAG (SET or RESET).
    860            */
    861          FlagStatus TIM3_GetFlagStatus(TIM3_FLAG_TypeDef TIM3_FLAG)
    862          {
    863            FlagStatus bitstatus = RESET;
    864            uint8_t tim3_flag_l = 0, tim3_flag_h = 0;
    865            
    866            /* Check the parameters */
    867            assert_param(IS_TIM3_GET_FLAG_OK(TIM3_FLAG));
    868            
    869            tim3_flag_l = (uint8_t)(TIM3->SR1 & (uint8_t)TIM3_FLAG);
    870            tim3_flag_h = (uint8_t)((uint16_t)TIM3_FLAG >> 8);
    871            
    872            if (((tim3_flag_l) | (uint8_t)(TIM3->SR2 & tim3_flag_h)) != (uint8_t)RESET )
    873            {
    874              bitstatus = SET;
    875            }
    876            else
    877            {
    878              bitstatus = RESET;
    879            }
    880            return (FlagStatus)bitstatus;
    881          }
    882          
    883          /**
    884            * @brief  Clears the TIM3’s pending flags.
    885            * @param   TIM3_FLAG specifies the flag to clear.
    886            * This parameter can be one of the following values:
    887            *                       - TIM3_FLAG_UPDATE: TIM3 update Flag
    888            *                       - TIM3_FLAG_CC1: TIM3 Capture Compare 1 Flag
    889            *                       - TIM3_FLAG_CC2: TIM3 Capture Compare 2 Flag
    890            *                       - TIM3_FLAG_CC1OF: TIM3 Capture Compare 1 over capture Flag
    891            *                       - TIM3_FLAG_CC2OF: TIM3 Capture Compare 2 over capture Flag
    892            * @retval None.
    893            */
    894          void TIM3_ClearFlag(TIM3_FLAG_TypeDef TIM3_FLAG)
    895          {
    896            /* Check the parameters */
    897            assert_param(IS_TIM3_CLEAR_FLAG_OK(TIM3_FLAG));
    898            
    899            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing ‘1’ has no effect*/
    900            TIM3->SR1 = (uint8_t)(~((uint8_t)(TIM3_FLAG)));
    901            TIM3->SR2 = (uint8_t)(~((uint8_t)((uint16_t)TIM3_FLAG >> 8)));
    902          }
    903          
    904          /**
    905            * @brief  Checks whether the TIM3 interrupt has occurred or not.
    906            * @param   TIM3_IT specifies the TIM3 interrupt source to check.
    907            * This parameter can be one of the following values:
    908            *                       - TIM3_IT_UPDATE: TIM3 update Interrupt source
    909            *                       - TIM3_IT_CC1: TIM3 Capture Compare 1 Interrupt source
    910            *                       - TIM3_IT_CC2: TIM3 Capture Compare 2 Interrupt source
    911            * @retval ITStatus The new state of the TIM3_IT(SET or RESET).
    912            */
    913          ITStatus TIM3_GetITStatus(TIM3_IT_TypeDef TIM3_IT)
    914          {
    915            ITStatus bitstatus = RESET;
    916            uint8_t TIM3_itStatus = 0, TIM3_itEnable = 0;
    917            
    918            /* Check the parameters */
    919            assert_param(IS_TIM3_GET_IT_OK(TIM3_IT));
    920            
    921            TIM3_itStatus = (uint8_t)(TIM3->SR1 & TIM3_IT);
    922            
    923            TIM3_itEnable = (uint8_t)(TIM3->IER & TIM3_IT);
    924            
    925            if ((TIM3_itStatus != (uint8_t)RESET ) && (TIM3_itEnable != (uint8_t)RESET ))
    926            {
    927              bitstatus = SET;
    928            }
    929            else
    930            {
    931              bitstatus = RESET;
    932            }
    933            return (ITStatus)(bitstatus);
    934          }
    935          
    936          /**
    937            * @brief  Clears the TIM3's interrupt pending bits.
    938            * @param   TIM3_IT specifies the pending bit to clear.
    939            * This parameter can be one of the following values:
    940            *                       - TIM3_IT_UPDATE: TIM3 update Interrupt source
    941            *                       - TIM3_IT_CC1: TIM3 Capture Compare 1 Interrupt source
    942            *                       - TIM3_IT_CC2: TIM3 Capture Compare 2 Interrupt source
    943            * @retval None.
    944            */
    945          void TIM3_ClearITPendingBit(TIM3_IT_TypeDef TIM3_IT)
    946          {
    947            /* Check the parameters */
    948            assert_param(IS_TIM3_IT_OK(TIM3_IT));
    949            
    950            /* Clear the IT pending Bit */
    951            TIM3->SR1 = (uint8_t)(~TIM3_IT);
    952          }
    953          
    954          /**
    955            * @brief  Configure the TI1 as Input.
    956            * @param   TIM3_ICPolarity  The Input Polarity.
    957            * This parameter can be one of the following values:
    958            *                       - TIM3_ICPOLARITY_FALLING
    959            *                       - TIM3_ICPOLARITY_RISING
    960            * @param   TIM3_ICSelection specifies the input to be used.
    961            * This parameter can be one of the following values:
    962            *                       - TIM3_ICSELECTION_DIRECTTI: TIM3 Input 1 is selected to
    963            *                         be connected to IC1.
    964            *                       - TIM3_ICSELECTION_INDIRECTTI: TIM3 Input 1 is selected to
    965            *                         be connected to IC2.
    966            * @param   TIM3_ICFilter Specifies the Input Capture Filter.
    967            * This parameter must be a value between 0x00 and 0x0F.
    968            * @retval None
    969            */
    970          static void TI1_Config(uint8_t TIM3_ICPolarity,
    971                                 uint8_t TIM3_ICSelection,
    972                                 uint8_t TIM3_ICFilter)
    973          {
    974            /* Disable the Channel 1: Reset the CCE Bit */
    975            TIM3->CCER1 &= (uint8_t)(~TIM3_CCER1_CC1E);
    976            
    977            /* Select the Input and set the filter */
    978            TIM3->CCMR1 = (uint8_t)((uint8_t)(TIM3->CCMR1 & (uint8_t)(~( TIM3_CCMR_CCxS | TIM3_CCMR_ICxF))) | (uint8_t)(( (TIM3_ICSelection)) | ((uint8_t)( TIM3_ICFilter << 4))));
    979            
    980            /* Select the Polarity */
    981            if (TIM3_ICPolarity != TIM3_ICPOLARITY_RISING)
    982            {
    983              TIM3->CCER1 |= TIM3_CCER1_CC1P;
    984            }
    985            else
    986            {
    987              TIM3->CCER1 &= (uint8_t)(~TIM3_CCER1_CC1P);
    988            }
    989            /* Set the CCE Bit */
    990            TIM3->CCER1 |= TIM3_CCER1_CC1E;
    991          }
    992          
    993          /**
    994            * @brief  Configure the TI2 as Input.
    995            * @param   TIM3_ICPolarity  The Input Polarity.
    996            * This parameter can be one of the following values:
    997            *                       - TIM3_ICPOLARITY_FALLING
    998            *                       - TIM3_ICPOLARITY_RISING
    999            * @param   TIM3_ICSelection specifies the input to be used.
   1000            * This parameter can be one of the following values:
   1001            *                       - TIM3_ICSELECTION_DIRECTTI: TIM3 Input 2 is selected to
   1002            *                         be connected to IC2.
   1003            *                       - TIM3_ICSELECTION_INDIRECTTI: TIM3 Input 2 is selected to
   1004            *                         be connected to IC1.
   1005            * @param   TIM3_ICFilter Specifies the Input Capture Filter.
   1006            * This parameter must be a value between 0x00 and 0x0F.
   1007            * @retval None
   1008            */
   1009          static void TI2_Config(uint8_t TIM3_ICPolarity,
   1010                                 uint8_t TIM3_ICSelection,
   1011                                 uint8_t TIM3_ICFilter)
   1012          {
   1013            /* Disable the Channel 2: Reset the CCE Bit */
   1014            TIM3->CCER1 &=  (uint8_t)(~TIM3_CCER1_CC2E);
   1015            
   1016            /* Select the Input and set the filter */
   1017            TIM3->CCMR2 = (uint8_t)((uint8_t)(TIM3->CCMR2 & (uint8_t)(~( TIM3_CCMR_CCxS |
   1018                                                                        TIM3_CCMR_ICxF    ))) | (uint8_t)(( (TIM3_ICSelection)) | 
   1019                                                                                                          ((uint8_t)( TIM3_ICFilter << 4))));
   1020            
   1021            /* Select the Polarity */
   1022            if (TIM3_ICPolarity != TIM3_ICPOLARITY_RISING)
   1023            {
   1024              TIM3->CCER1 |= TIM3_CCER1_CC2P;
   1025            }
   1026            else
   1027            {
   1028              TIM3->CCER1 &= (uint8_t)(~TIM3_CCER1_CC2P);
   1029            }
   1030            
   1031            /* Set the CCE Bit */
   1032            TIM3->CCER1 |= TIM3_CCER1_CC2E;
   1033          }
   1034          
   1035          /**
   1036            * @}
   1037            */
   1038            
   1039            /**
   1040            * @}
   1041            */
   1042            
   1043          
   1044          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

Errors: 50
Warnings: none
